<!DOCTYPE html>

<html>

<head>
	<title>Shape emitter - Physijs</title>
	
	<link rel="stylesheet" type="text/css" href="stylesheets/styles.css" />
	
	<script type="text/javascript" src="javascripts/three.min.js"></script>
	<script type="text/javascript" src="javascripts/stats.js"></script>
	<script type="text/javascript" src="javascripts/tween.js"></script>
	<script type="text/javascript" src="javascripts/physi.js"></script>
	<script type="text/javascript" src="javascripts/ConvexGeometry.js"></script>
	<script type="text/javascript" src="javascripts/RandomPolyhedron.js"></script>
	<script type="text/javascript" src="javascripts/PolyhedronVolumeCalculator.js"></script>
	<script type="text/javascript" src="javascripts/Pyramid.js"></script>
	<script type="text/javascript" src="javascripts/Polygon.js"></script>
	<script type="text/javascript" src="javascripts/Vector.js"></script>
	<script type="text/javascript" src="javascripts/Point.js"></script>
	<script type="text/javascript" src="javascripts/fileutils.js"></script>
	<script type="text/javascript" src="javascripts/FileSaver.min.js"></script>

	
	<script type="text/javascript">
	
	'use strict';
	
	Physijs.scripts.worker = 'javascripts/physijs_worker.js';
	Physijs.scripts.ammo = 'ammo.js';
	
	var initScene, render, createShape,
		renderer, render_stats, physics_stats, scene, light, ground, ground_material, wall_material, camera, axis;

	var total_volume = 0.0;
	var box_volume = 0.0;
	var rate = 0.0;
	
	initScene = function() {
		TWEEN.start();
		
		renderer = new THREE.WebGLRenderer({ antialias: true });
		renderer.setSize( window.innerWidth, window.innerHeight );
		renderer.shadowMapEnabled = true;
		renderer.shadowMapSoft = true;
		document.getElementById( 'viewport' ).appendChild( renderer.domElement );
		
		render_stats = new Stats();
		render_stats.domElement.style.position = 'absolute';
		render_stats.domElement.style.top = '0px';
		render_stats.domElement.style.zIndex = 100;
		document.getElementById( 'viewport' ).appendChild( render_stats.domElement );
		
		physics_stats = new Stats();
		physics_stats.domElement.style.position = 'absolute';
		physics_stats.domElement.style.top = '50px';
		physics_stats.domElement.style.zIndex = 100;
		document.getElementById( 'viewport' ).appendChild( physics_stats.domElement );
		
		scene = new Physijs.Scene({ fixedTimeStep: 1 / 120 });
		scene.setGravity(new THREE.Vector3( 0, -30, 0 ));
		scene.addEventListener(
			'update',
			function() {
				scene.simulate( undefined, 2 );
				physics_stats.update();
			}
		);
		
		camera = new THREE.PerspectiveCamera(
			35,
			window.innerWidth / window.innerHeight,
			1,
			1000
		);
		// camera.position.set( 60, 50, 60 );
//		camera.position.set( 450, 350, 450 );
		camera.position.set( 450, 150, 450 );
//		camera.position.set( 0, 350, 0 );
//		camera.position.set( 450, 0, 450 );

		camera.lookAt( scene.position );
//		camera.lookAt( );
		scene.add( camera );

		// Axis
		axis = new THREE.AxisHelper( 190 );
		axis.position.set( 0, 0, 0 );
		scene.add( axis );
		
		// Light
		light = new THREE.DirectionalLight( 0xFFFFFF );
		light.position.set( 100, 100, -15 );
		light.target.position.copy( scene.position );
		light.castShadow = false;
		light.shadowCameraLeft = -60;
		light.shadowCameraTop = -60;
		light.shadowCameraRight = 60;
		light.shadowCameraBottom = 60;
		light.shadowCameraNear = 20;
		light.shadowCameraFar = 200;
		light.shadowBias = -.0001
		light.shadowMapWidth = light.shadowMapHeight = 2048;
		light.shadowDarkness = .7;
		scene.add( light );
		
		// Materials
		wall_material = Physijs.createMaterial(
		//new THREE.MeshLambertMaterial( { ambient: 0xf6f6f6, transparent: true}),//, map: map } ),
			new THREE.MeshBasicMaterial( { color: 0xffffff, wireframe: true, transparent: true, opacity: 1 } )
		);
		ground_material = Physijs.createMaterial(
			new THREE.MeshLambertMaterial({ map: THREE.ImageUtils.loadTexture( 'images/rocks.jpg' ) }),
			.8, // high friction
			.4 // low restitution
		);
		ground_material.map.wrapS = ground_material.map.wrapT = THREE.RepeatWrapping;
		ground_material.map.repeat.set( 2.5, 2.5 );
		

//		createShape();

//		randomGenAndPutInSubBox3();

		readFile("cfg.json", function (options) {

//			console.log(JSON.stringify(options));
			options = JSON.parse(options);
			if (options.container.type == "cylinder") {
				initCylinderScene(options);
				requestAnimationFrame( render );
				scene.simulate();
				randomGenAndPutInCylinder(options);
			} else {
				initBoxScene(options);
				requestAnimationFrame( render );
				scene.simulate();
				randomGenAndPutInSubBox3(options);
			}

		});

//		randomGenAndPut();
//		function dosomething() {
//			var allConvexs = randomGenAndPutInSubBox2();
////		var allConvexs = randomGenAndPutInSubBox();
//			var shape, material = new THREE.MeshLambertMaterial({opacity: 0, transparent: true});
//			for (var i = 0; i < allConvexs.length; i++) {
//				var curr = allConvexs[i];
//				shape = new Physijs.ConvexMesh(
//						curr,
//						material
//				);
//
//				var volume = calculate(curr);
//				total_volume += volume;
//				rate = total_volume / box_volume;
//				// console.log("Vertices: " + JSON.stringify(convex_geometry.vertices));
//				console.log("Volume: " + volume);
//				console.log("Rate: " + rate * 100 + "%")
//				shape.material.color.setRGB(Math.random() * 100 / 100, Math.random() * 100 / 100, Math.random() * 100 / 100);
//				shape.castShadow = false;
//				shape.receiveShadow = false;
//
//				scene.add(shape);
//
//				new TWEEN.Tween(shape.material).to({opacity: 1}, 500).start();
//
//				document.getElementById('shapecount').textContent = i + ' shapes created';
//			}
//		}
		setTimeout(function() {

			// Get current geometries

			var result = "";
			for (var i = 9; i < scene.children.length; i++) {
				var curr = scene.children[i].geometry;
				var curr_matrix = scene.children[i].matrix;

				curr.applyMatrix(curr_matrix);

				var points = [];
				for (var j = 0; j < curr.vertices.length; j++) {
					points.push([curr.vertices[j].x, curr.vertices[j].y, curr.vertices[j].z]);
				}

				var faces = [];
				for (var j = 0; j < curr.faces.length; j++) {
					faces.push([curr.faces[j].a, curr.faces[j].b, curr.faces[j].c]);
				}

				result +=
						"polyhedron("
						+ "points="
						+ JSON.stringify(points)
						+ ","
						+ "faces="
						+ JSON.stringify(faces)
						+ ""
						+ ");\n";

			}

//			console.log(result);

//			var blob = new Blob([result], {type: 'text/plain'});
//			saveAs(blob, "result.me");
//			downloadFile(result);

			var ipc = require('ipc');
			if (ipc.sendSync('synchronous-message', result) == "close") { // prints "pong"

//				window.close();
			}

//			ipc.on('asynchronous-reply', function(arg) {
//				console.log(arg); // prints "pong"
//			});
//			ipc.send('asynchronous-message', 'ping');

		}, 30000);

	};
	
	render = function() {
		requestAnimationFrame( render );
		renderer.render( scene, camera );
		render_stats.update();
	};


	// var box = {
 //        vertex3A: new THREE.Vector3(-25, -25, -25),
 //        vertex3B: new THREE.Vector3(25, 25, 25),
 //        objects: []
 //    };
	// var minR = 20, maxR = 30;
 //    var minVertices = 4, maxVertices = 4;
	// var randomConvex = randomConvexNonIntersected(minR, maxR, minVertices, maxVertices, box, randomSphereInBox);

	createShape = (function() {
		
        // console.log("points: " + JSON.stringify(convex.vertices));
        // console.log("faces: " + JSON.stringify(convex.faces[0]));
        // console.log(JSON.stringify(convex));

		var addshapes = true,
			shapes = 0,
			box_geometry = new THREE.BoxGeometry( 3, 3, 3 ),
			sphere_geometry = new THREE.SphereGeometry( 1.5, 32, 32 ),
			cylinder_geometry = new THREE.CylinderGeometry( 2, 2, 1, 32 ),
			cone_geometry = new THREE.CylinderGeometry( 0, 2, 4, 32 ),
			octahedron_geometry = new THREE.OctahedronGeometry( 1.7, 1 ),
			torus_geometry = new THREE.TorusKnotGeometry ( 1.7, .2, 32, 4 ),
			// convex_geometry = convex,
			doCreateShape;
		
		setTimeout(
			function addListener() {
				var button = document.getElementById( 'stop' );
				if ( button ) {
					button.addEventListener( 'click', function() { addshapes = false; } );
				} else {
					setTimeout( addListener );
				}
			}
		);
			
		doCreateShape = function() {
			var shape, material = new THREE.MeshLambertMaterial({ opacity: 0, transparent: true });
			var minR = 5, maxR = 10;
			var minVertices = 4, maxVertices = 6;
			var sphere = randomSphereInBox(minR, maxR, {vertex3A: new THREE.Vector3(-25, -25, -25), vertex3B: new THREE.Vector3(25, 25, 25)});
        	var convex = randomConvexInSphere(minVertices, maxVertices, sphere);
        	// var convex = randomConvex();
        	if (convex == undefined)  {
        		return function() {
					setTimeout( doCreateShape, 100 );
				};
			}

        	var convex_geometry = convex;
			// switch (6) {
			switch ( Math.floor(Math.random() * 7) ) {
				case 0:
					shape = new Physijs.BoxMesh(
						// box_geometry,
						convex_geometry,
						material
					);
					break;
				
				case 1:
					shape = new Physijs.SphereMesh(
						// sphere_geometry,
						convex_geometry,
						material,
						undefined,
						{ restitution: Math.random() * 1.5 }
					);
					break;
				
				case 2:
					shape = new Physijs.CylinderMesh(
						// cylinder_geometry,
						convex_geometry,
						material
					);
					break;
				
				case 3:
					shape = new Physijs.ConeMesh(
						// cone_geometry,
						convex_geometry,
						material
					);
					break;
				
				case 4:
					shape = new Physijs.ConvexMesh(
						// octahedron_geometry,
						convex_geometry,
						material
					);
					break;
				
				case 5:
					shape = new Physijs.ConvexMesh(
						// torus_geometry,
						convex_geometry,
						material
					);
					break;
				case 6:
					shape = new Physijs.ConvexMesh(
						convex_geometry,
						material
					);

					var volume = calculate(convex_geometry);
					total_volume += volume;
					rate = total_volume / box_volume;
					// console.log("Vertices: " + JSON.stringify(convex_geometry.vertices));
					console.log("Volume: " + volume);
					console.log("Rate: " + rate * 100 + "%")

					break;
			}
				
			shape.material.color.setRGB( Math.random() * 100 / 100, Math.random() * 100 / 100, Math.random() * 100 / 100 );
			shape.castShadow = false;
			shape.receiveShadow = false;
			
			// shape.position.set(
			// 	Math.random() * 30 - 15,
			// 	40,
			// 	Math.random() * 30 - 15   
			// );
			
			shape.position.set(
				randomBetween(-25, -15),
				10,
				randomBetween(-25, -15)   
			);

			// shape.position.set(convex_geometry.position);
			
			// shape.rotation.set(
			// 	Math.random() * Math.PI,
			// 	Math.random() * Math.PI,
			// 	Math.random() * Math.PI
			// );

			// var constraint = new Physijs.SliderConstraint(
			//     shape, // First object to be constrained
			//     new THREE.Vector3( 0, 50, 0 ), // point in the scene to apply the constraint
			//     new THREE.Vector3( 0, 1, 0 ) // Axis along which the hinge lies - in this case it is the X axis
			// );
			// scene.addConstraint( constraint );

			// constraint.setLimits(
			//     linear_lower, // lower limit of linear movement, expressed in world units
			//     linear_upper, // upper limit of linear movement, expressed in world units
			//     angular_lower, // lower limit of angular movement, expressed in radians
			//     angular_upper // upper limit of angular movement, expressed in radians
			// );
			// constraint.setRestitution(
			//     linear, // amount of restitution when reaching the linear limits
			//     angular // amount of restitution when reaching the angular limits
			// );
			// constraint.enableLinearMotor( target_velocity, acceration_force );
			// constraint.disableLinearMotor();
			// constraint.enableAngularMotor( target_velocity, acceration_force );
			// constraint.disableAngularMotor();
			
			if ( addshapes ) {
				shape.addEventListener( 'ready', createShape );
				shape.addEventListener('collision', function(other_object, linear_velocity) {
					var _vector = new THREE.Vector3;
					_vector.set( 0, 0, 0 );
					this.setAngularFactor( _vector );
					this.setAngularVelocity( _vector );
					this.setLinearFactor( _vector );
					this.setLinearVelocity( _vector );
				});
			}

			
			scene.add( shape );
			// setTimeout(function() {
			// 	// if ( shape.collisions.length > 5 ) {
			// 		var _vector = new THREE.Vector3;
			// 		_vector.set( 0, 0, 0 );
			// 		shape.setAngularFactor( _vector );
			// 		shape.setAngularVelocity( _vector );
			// 		shape.setLinearFactor( _vector );
			// 		shape.setLinearVelocity( _vector );
			// 	// }
				
			// }, 10000);
			
			new TWEEN.Tween(shape.material).to({opacity: 1}, 500).start();
			
			document.getElementById( 'shapecount' ).textContent = ( ++shapes ) + ' shapes created';
		};
		
		return function() {
			setTimeout( doCreateShape, 100 );
		};
	})();
	
	window.onload = initScene;
	
	</script>
</head>

<body>
	<div id="heading">
		<!--<h1>Shapes in Physijs</h1>-->
		<!--<p>-->
			<!--All of the supported shapes in Physijs --->
			<!--<span id="shapecount"></span> <button id="stop">Stop adding shapes</button><br />-->
		<!--</p>-->
	</div>
	<div id="viewport"></div>
</body>

</html>